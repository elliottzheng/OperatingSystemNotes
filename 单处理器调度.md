单处理器调度：

调度类型

- 长
- 中
- 短
- IO

长程调度：程序（进程）=》系统（进程池），道数相关

中程调度：交换，换入换出，内存相关

短程：执行，CPU

IO:

调度评价准则：

- 进程=》CPU=》执行

- 吞吐率

- 周转时间
- CPU效率

分类：

- 系统+用户

- 性能+非性能

用户+性能：

1. 周转时间
2. 等待事件
3. 最后期限
4. 响应时间

用户+非性能：

- 可预测性

系统+性能：

- CPU使用率
- 吞吐率、吞吐量

系统+非性能

- 进程角度：公平性，没有饥饿现象

- 资源角度：平衡性（所有资源负载均衡），进程的类型以及进程对资源的使用情况

  （heavy CPU，heavy IO）

- 强制优先级，

  优先级=》饥饿=》动态优先级

  1. 对已执行时间的惩罚
  2. 对等待的奖励

策略模式：

- 抢占
- 非抢占（默认）

具体调度算法（短程调度）

1. FCFS,FIFO

   按到达的顺序排队，调度队首进程

2. RR

   时间片，每个进程一次调度最多使用一个时间片

   时间片长短：略大于一次典型交互时间

   偏向HeavyCPU进程

   HeavyIO进程受到不公平待遇（IO操作让进程处于阻塞状态=》IO完成=》重新进入就绪队列）在IO操作的时候，该进程没有使用完整个时间片=》补偿=》VRR

   =》进程=》CPU使用权=》IO操作=》阻塞队列=》辅助队列（高优先级的就绪队列）=》优先被调度=》CPU使用权（使用时间《=时间片-$\sgma$(上次从就绪队列开始被调度使用CPU的时间)）

3. SPN

   进程的执行如何估计

   历史数据：

​	- 均值方法

指数方法，参数，跟随变化

SRT

SPN的抢占式版本

剩余时间的估计=执行时间-已执行时间



HRRN

hrrn=(w+s)/s=w/s+1



FEEDBACK

每执行一次，降低一个优先级

同一个优先级FCFS

最后一个优先级（队列）RR

不同优先级的队列获得cpu的概率不同

长进程=》长时间等待（经过多次执行后还未结束，并处于较低优先级的队列中=》意味着获得CPU的概率低）

饥饿

=》改进反馈算法

获得CPU使用权的概率低的队列=》给与更多的CPU（指数级别增长）2^i，

没有解决饥饿问题

=》奖励方法=》等待时间到达一定程度=》提升进程的优先级

1. 优先级级数有限

2. 等待时间程度有限（提升）

   =》有限时间达到最高优先级

3. 达到最高优先级是，该队列中的等待进程是有限的

4. 进程的执行时间是有限的

5. FCFS调度算法，=》在有限的时间内该进程可以获得CPU=segma(Pi*T_i)

=>该进程不会饥饿

算法没有好坏之分，只有适用不适用

