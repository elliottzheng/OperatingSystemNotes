虚拟内存

为什么可行？

1. 程序可以分块
2. 部分加载到内存（要运行部分）
3. 运行时，不在内存中，再加载
4. 部分加载到内存中的块可以是不连续的

虚拟内存=》扩充内存=》增加多道程序设计的道数（挂起，虚拟内存，部分加载，分配部分内存给用户程序）



如何在需要的时候加载不在内存中的块（类似于缺页处理的过程）？

1. 发出不在内存的中断
2. 进程=》阻塞
3. OS加载程序块到内存（对程序员透明）
4. 用户内存满的问题（置换算法）
5. 加载完成，进程=》就绪
6. 重新进行调度

系统抖动

如果系统大部分时间都用于交换（IO操作）而没有执行用户指令，使得系统进程处于基本停滞状态=》系统抖动=》硬盘灯一直闪，界面卡住

如何避免系统抖动？

原因：马上要使用的块被换出，使用时候又被换入，并且这种现象频率很高=》块的使用预测不准=》提高预测的准确度=》用历史的数据=》原理：局部性原理（空间+时间）

页式管理：

1. 进程分页
2. 内存分帧
3. 页帧等大小

地址映射：页表，逻辑地址=》物理地址 

物理地址=帧号+偏移量

页号=》帧号的对应关系

页表项：帧号信息

该页是否被加载到内存：P（1位），存在位

该页被置换时是否需要会写=》内存中的帧和硬盘（虚拟内存）中的进程中的页是否一致=》M（1位），修改位



指令或数据的访问由原来的一次变为两次，

1. 访问页表
2. 访问指令或数据

需要提升速度

- 针对页表=》TLB（特殊的缓存）
- 

地址映射：

1. 只有页表

   1. 访问指令/数据（逻辑地址）
   2. 页号
   3. 找到页表项
   4. P==1，取出帧号，形成物理地址
   5. P==0，缺页中断=》进程=》阻塞
   6. OS缺页处理
   7. 完成，进程=》就绪
   8. 重新获得CPU使用权
   9. 逻辑地址
   10. 页号
   11. 页表项
   12. 取出帧号（P==1一定），形成物理地址

2. 页表+TLB

   TLB：硬件特性，级联查找设备（在一次访问时间内，能够判断出所查找的数据是否在TLB中，如果在，返回该数据在TLB中的位置）地址映射路径2=》3条

   1. TLB中存在所对应的页表项
   2. 页表+P==1，更新TLB
   3. 页表+P==0，缺页中断，，页错误（在缺页处理完成时，需要更新页表，需要更新那些项目？1. 存在位P，2.帧号），然后执行2

3. 页表+TLB+Cache

   五条路径

   1. TLB+Cache
   2. TLB+内存
   3. 页表（P==1）+Cache
   4. 页表（P==0）+内存
   5. 页表（P==0）+缺页+4



   页表要占用内存空间的

   1. 进程太多，每个进程一个页表

   2. 进程很大，页表很大

      页表占用太多内存

      1. 把页表放在虚拟内存中（二级页表，页表的页表）
      2. 限制页表的大小（倒排页表）

      二级页表：
      逻辑地址=页号1+页号2+页内偏移量

      物理地址=帧号+帧内偏移量

      一个进程对应两个页表？2

      地址映射，分成两次

      一次：页表所对应的首地址

      二次：帧号

      倒排页表：

   ​	帧号与页号的对应关系

   ​	页号，每个进程都是从0开始编号，重复对应关系的时候，需要知道对应的是哪个仅存的页号？

   ​	页表中，页,PID

   Hash函数做页号到帧号的映射，M-1关系=》多个页号映射到同一个帧号=》重复，重叠=》解决？链指针（把所有对应到同一个帧号的页号链接起来）=》线性散列，溢出链表

   页表的大小和哪些因素有关？

   1. 进程大小
   2. 进程数量
   3. 帧号大小
   4. 页大小
   5. 控制位

   倒排页表的大小和哪些因素有关

   1. 内存大小
   2. 帧号大小
   3. 
