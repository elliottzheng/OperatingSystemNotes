并发性：互斥与同步

并发性无处不在，应用程序，管理程序，os=>并发性引发的问题无可避免=》解决

## 概念

临界区：代码段，互斥

死锁：两个或两个以上的一组进程，互相等待，无法继续执行（就绪）

等待：无法继续执行（就绪）

活锁：为了其他进程能够继续执行而做的改变（无用功）

互斥：一次最多只有一个进程执行

饥饿：就绪进程，无限期忽视，无法获得CPU控制权。无法继续执行。

竞争条件：共享变量，失败者决定最后的值。

OS关注问题：

1. 进程：跟踪
2. 资源：分配和资源
3. 保护：进程和资源

进程间的关系

1. 互相不知道：竞争，互斥，死锁，饥饿
2. 知道对方（不知道ID）：共享：竞争，互斥，死锁，饥饿
3. 知道对方（ID）：直接通讯，共享，合作

并发性问题：

- 本质：并发=》不并发（串行）
- 规则：一次只允许一个进程进入=>临界区

并发=》物理并行（多CPU）+逻辑并行（单CPU）=》统一解决方案（禁用中断例外）

## 临界区解决方案

1. 禁用中断
2. compare_and_swap
3. exchange
4. 信号量
5. 管程
6. 消息

## 判断临界区方案的有效性

不能死锁，不能饥饿，细粒度尽可能小

1. 临界区没有执行的进程，一个想进入临界区的进程可以立即进入
2. 临界区中有执行的进程，其他进程无法进入（等待）
3. 临界区中的进程要在有限的时间内离开（执行完毕）=》条件的重置
4. 临界区中执行的进程离开后，等待的进程能进入

临界区：

- EnterCritical(Ra)

- ExitCritical（Ra）

## 禁用中断

- 禁用中断
- 临界区
- 启用中断
- 代价大，细粒度是系统级的，对多CPU无效

## Compare_and_swap

##### 三个参数，一个返回

001

101

`while(compare_and_swap(bolt,0,1)==1);`

临界区

bolt=0

忙等待，饥饿，死锁（低优先级进程在临界区中被抢占）

exchange(v1,v2)

keyi进程的局部变量

```C++
while(keyi!=1)
    exchange(keyi,bolt);
```

临界区（）

`exchange(keyi,boly);//bolt=0`

## 信号量

```C++
struct semaphore{
    int count;//
    Queue q;//信号量下的
}
```

原语：

```
semSignal(s);V(s);
semWait(s);P(s);
先加减后再判断
semWait(s)
```





